/*  conquering-codeforces
 *  day 30. #144A
 *
 *  Задача: В Самую Секретную Военную Часть под командованием полковника Покрышкина приехал с проверкой генерал из
 *          Министерства Обороны. По этому случаю полковник приказал n солдатам из своей Части построиться на плацу.
 *          Согласно военному уставу, солдаты должны стоять в порядке невозрастания их роста, но так как времени на
 *          построение совсем не осталось, то солдаты выстроились в произвольном порядке. Однако у генерала весьма
 *          плохое зрение, и поэтому он считает, что солдаты построены правильно, если самый первый в строю — солдат
 *          с максимальным ростом, а самый последний — солдат с минимальным ростом. Обратите внимание, что неважно то,
 *          как расположены остальные солдаты, в том числе и в случае нескольких максимальных или минимальных по росту
 *          солдат. Важны лишь росты первого и последнего солдата. За одну секунду полковник может обменять местами
 *          любых двух соседних солдат. Помогите ему подсчитать, какое минимальное количество секунд понадобится,
 *          чтобы получившийся строй понравился генералу.
 *  Входные данные: Первая строка входных данных содержит единственное целое число n (2 ≤ n ≤ 100) — количество солдат
 *                  в строю. Вторая строка содержит целые числа a1, a2, ..., an (1 ≤ ai ≤ 100) — величины ростов солдат
 *                  в порядке от начала строя к концу. Числа разделены пробелом и не обязательно различны.
 *  Выходные данные: Выведите единственное целое число — какое минимальное количество секунд понадобится полковнику,
 *                   чтобы получившийся строй понравился генералу.
 */

import java.util.Scanner;

public class CF144A
{
    public static void main(String[] args)
    {
        Scanner scanner = new Scanner(System.in);

        int n = Integer.parseInt(scanner.nextLine());

        int[] growth = new int[n];

        for (int i = 0; i < growth.length; i++) {
            growth[i] = scanner.nextInt();
        }

        int output = 0;

        int max = -1;
        int index_max = -1;

        for (int i = 0; i < growth.length; i++) {
            if (growth[i] > max) {
                max = growth[i];
                index_max = i;
            }
        }

        for (int i = index_max; i > 0; i--) {
            int temp = growth[i];
            growth[i] = growth[i - 1];
            growth[i - 1] = temp;

            output += 1;
        }

        int min = 101;
        int index_min = n;

        for (int i = 0; i < growth.length; i++) {
            if (growth[i] <= min) {
                min = growth[i];
                index_min = i;
            }
        }

        for (int i = index_min; i < growth.length - 1; i++) {
            int temp = growth[i];
            growth[i] = growth[i + 1];
            growth[i + 1] = temp;

            output += 1;
        }

        System.out.println(output);
    }
}
